lexer grammar LyraLexer;
FOREVER                 : 'forever';
SWITCH                  : 'switch';
CASE                    : 'case';
WHILE                   : 'while';
FOR                     : 'for';
IF                      : 'if';
ELSE                    : 'else';
SUPER                   : 'super';
RETURN                  : 'return';
CONTINUE                : 'continue';
BREAK                   : 'break';
NOT                     : '!';
DOT                     : '.';
ENUM                    : 'enum';
DEFAULT                 : 'default';
COLON                   : ':';
INFIX                   : 'infix';
DEF                     : 'def';
NEW                     : 'new';
LEFTPARENTHESES         : '(';
RIGHTPARENTHESES        : ')';
MODOP                   : '%';
SLASH                   : '/';
MULTOP                  : '*';
PLUS                    : '+';
MINUS                   : '-';
MORETHANOREQUAL         : '>=';
MORETHAN                : '>';
LESSTHANOREQUAL         : '<=';
LESSTHAN                : '<';
IS                      : 'is';
AND                     : 'and';
OR                      : 'or';
NOTEQUAL                : '!=';
DOUBLEEQUALOP           : '==';
EQUALOP                 : '=';
INTERFACE               : 'interface';
IMPLEMENTS              : 'implements';
VISIBILITY_MODIFIER     : 'public' | 'protected' | 'private' ;
ABSTRACT                : 'abstract';
FINAL                   : 'final';
COMMA                   : ',';
RIGHTCURLYBRACE         : '}';
LEFTCURLYBRACE          : '{';
LEFTBRACKET            : '[';
RIGHTBRACKET             : ']';
EXTENDS                 : 'extends';
CLASS                   : 'class' ;
SEMICOLON               : ';' ;
IMPORT                  : 'import';
IDENT                   : [a-zA-Z_] [a-zA-Z_0-9]* ;
STRING                  : '"' ( '\\"' | . )*? '"' ;
NUMBER                  : ([0-9] | [1-9][0-9]*)( '.' [0-9]+ )? ;
INCREMENT_DECREMENT     : ('++' | '--') ;
BOOLEAN_VALUE           : 'true' | 'false' ;
NULL                    : 'null' ;
COMMENT                 : '/*' .*? '*/' -> skip ; // .*? matches anything until the first */
LINECOMMENT             : '//' .*? ('\r' | '\n') -> skip ;
WS                      : [ \t\r\n]+ -> skip ; // skip spaces, tabs, newlines
